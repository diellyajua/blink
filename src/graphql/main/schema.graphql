type Query {
  me: User
}

type User {
  id: ID!
  username: Username
  phone: Phone!
  language: Language!
  defaultAccount: Account!
  createdAt: Timestamp!
}

"""Unique identifier of an API user"""
scalar Username

"""Phone number which includes country code"""
scalar Phone

enum Language {
  EN_US
  ES_SV
}

interface Account {
  level: AccountLevel!
  status: AccountStatus!
  wallets: [Wallet!]!
}

enum AccountLevel {
  ONE
  TWO
}

enum AccountStatus {
  LOCKED
  ACTIVE
}

interface Wallet {
  id: ID!
  transactions(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
  ): TransactionConnection
}

"""A connection to a list of items."""
type TransactionConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TransactionEdge]
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""An edge in a connection."""
type TransactionEdge {
  """The item at the end of the edge"""
  node: Transaction

  """A cursor for use in pagination"""
  cursor: String!
}

interface Transaction {
  id: ID!
  createdAt: Timestamp!
}

"""
Date field, serialized as the number of milliseconds since the Unix Epoch
"""
scalar Timestamp

type Mutation {
  lnNoAmountInvoiceCreateOnBehalfOfRecipient(input: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput!): LnNoAmountInvoicePayload!
}

type LnNoAmountInvoicePayload {
  errors: [UserError!]!
  invoice: LnNoAmountInvoice
}

type UserError {
  message: String!
  fields: [String!]!
}

type LnNoAmountInvoice {
  paymentRequest: LnInvoicePaymentRequest!
  paymentHash: LnInvoicePaymentHash!
  paymentSecret: LnInvoicePaymentSecret!
}

scalar LnInvoicePaymentRequest

scalar LnInvoicePaymentHash

scalar LnInvoicePaymentSecret

input LnNoAmountInvoiceCreateOnBehalfOfRecipientInput {
  recipient: Username!
  memo: Memo
}

"""Text field in a lightning payment transaction"""
scalar Memo

type Subscription {
  lnInvoicePaymentStatus(input: LnInvoicePaymentStatusInput!): LnInvoicePaymentStatusPayload!
}

type LnInvoicePaymentStatusPayload {
  errors: [UserError!]!
  status: InvoicePaymentStatus
}

enum InvoicePaymentStatus {
  PENDING
  PAID
}

input LnInvoicePaymentStatusInput {
  paymentRequest: LnInvoicePaymentRequest!
  lookupToken: String!
}
