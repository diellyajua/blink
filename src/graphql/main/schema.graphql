type Query {
  me: User
}

type User {
  id: ID!
  phone: Phone!
  language: Language!
  defaultAccount: Account!
  contacts: [Contact!]!
  quizQuestions: [UserQuizQuestion!]!
  createdAt: Timestamp!
}

"""
Phone number which includes country code
"""
scalar Phone

enum Language {
  EN_US
  ES_SV
}

interface Account {
  level: AccountLevel!
  status: AccountStatus!
  wallets: [Wallet!]!
  canWithdraw: Boolean!
  limits: Limits!
  csvTransactions(walletIds: [ID!]!): String!
}

enum AccountLevel {
  ONE
  TWO
}

enum AccountStatus {
  LOCKED
  ACTIVE
}

interface Wallet {
  id: ID!
  transactions(
    """
    Returns the items in the list that come after the specified cursor.
    """
    after: String

    """
    Returns the first n items from the list.
    """
    first: Int

    """
    Returns the items in the list that come before the specified cursor.
    """
    before: String

    """
    Returns the last n items from the list.
    """
    last: Int
  ): TransactionConnection
}

"""
A connection to a list of items.
"""
type TransactionConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  A list of edges.
  """
  edges: [TransactionEdge]
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: String

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: String
}

"""
An edge in a connection.
"""
type TransactionEdge {
  """
  The item at the end of the edge
  """
  node: Transaction

  """
  A cursor for use in pagination
  """
  cursor: String!
}

interface Transaction {
  id: ID!
  initiationVia: PaymentInitiationMethod!
  settlementVia: SettlementMethod!
  settlementAmount: SatAmount!
  settlementFee: SatAmount!
  priceAtSettlement: BtcUsdPrice!
  direction: TxDirection!
  memo: Memo
  status: TxStatus
  createdAt: Timestamp!
}

enum PaymentInitiationMethod {
  WALLET_NAME
  ON_CHAIN
  LIGHTNING
}

enum SettlementMethod {
  INTRA_LEDGER
  ON_CHAIN
  LIGHTNING
}

"""
(Positive) Satoshi amount (i.g. quiz earning)
"""
scalar SatAmount

type BtcUsdPrice {
  id: ID!
  timestamp: Timestamp!
  price: Float!
}

"""
Date field, serialized as the number of milliseconds since the Unix Epoch
"""
scalar Timestamp

enum TxDirection {
  SEND
  RECEIVE
}

"""
Text field in a lightning payment transaction
"""
scalar Memo

enum TxStatus {
  PENDING
  SUCCESS
  FAILURE
}

type Limits {
  maxSend: Int!
  intraLedgerMaxSend: Int!
}

type Contact {
  id: ID!
  name: FullName
  transactionsCount: Int!
}

"""
Full name of an API user
"""
scalar FullName

type UserQuizQuestion {
  question: QuizQuestion!
  completed: Boolean!
}

type QuizQuestion {
  id: ID!

  """
  The earn reward in Satoshis for the quiz question
  """
  earnAmount: SatAmount!
}

type Mutation {
  userRequestAuthCode(input: UserRequestAuthCodeInput!): SuccessPayload!
  userLogin(input: UserLoginInput!): AuthTokenPayload!
  lnNoAmountInvoiceCreateOnBehalfOfRecipient(
    input: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput!
  ): LnNoAmountInvoicePayload!
  lnNoAmountInvoiceCreate(input: LnNoAmountInvoiceCreateInput!): LnNoAmountInvoicePayload!
}

type SuccessPayload {
  errors: [UserError!]!
  success: Boolean
}

type UserError {
  message: String!
}

input UserRequestAuthCodeInput {
  phone: Phone!
}

type AuthTokenPayload {
  errors: [UserError!]!
  authToken: AuthToken
}

"""
An authentication code valid for a single use
"""
scalar AuthToken

input UserLoginInput {
  phone: Phone!
  code: OneTimeAuthCode!
}

"""
An authentication code valid for a single use
"""
scalar OneTimeAuthCode

type LnNoAmountInvoicePayload {
  errors: [UserError!]!
  invoice: LnNoAmountInvoice
}

type LnNoAmountInvoice {
  paymentRequest: LnInvoicePaymentRequest!
  paymentHash: LnInvoicePaymentHash!
  paymentSecret: LnInvoicePaymentSecret!
}

"""
BOLT11 lightning invoice payment request with the amount included
"""
scalar LnInvoicePaymentRequest

scalar LnInvoicePaymentHash

scalar LnInvoicePaymentSecret

input LnNoAmountInvoiceCreateOnBehalfOfRecipientInput {
  recipient: WalletName!
  memo: Memo
}

"""
Unique identifier of an account wallet
"""
scalar WalletName

input LnNoAmountInvoiceCreateInput {
  memo: Memo
}

type Subscription {
  lnInvoicePaymentStatus(
    input: LnInvoicePaymentStatusInput!
  ): LnInvoicePaymentStatusPayload!
}

type LnInvoicePaymentStatusPayload {
  errors: [UserError!]!
  status: InvoicePaymentStatus
}

enum InvoicePaymentStatus {
  PENDING
  PAID
}

input LnInvoicePaymentStatusInput {
  paymentRequest: LnInvoicePaymentRequest!
  lookupToken: String!
}
