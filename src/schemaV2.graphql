union IntraLedgerDestination =
    IntraLedgerDestination
  | OnChainDestination
  | LnDestination
  | FeeReimbursementDestination

type WalletNameDestination {
  destination: WalletName!
}

type OnChainDestination {
  destination: OnChainAddress!
}

type LnDestination {
  destination: LnInvoicePaymentHash
}

type FeeReimbursementDestination {
  destination: FeeReimbursementHash
}

# ?: Using the same wallet (ex, Bitcoin Beach)
# ?: 1) Pay with WalletName, 2) Pay with LN, 3) Pay OnChain
type WalletNameTransaction implements Transaction {
  id: ID!
  direction: TxDirection!

  settlementAmount: SatAmount!
  settlementFee: SatAmount!

  priceAtSettlement: BtcPrice

  memo: Memo
  status: TxStatus!
  createdAt: Date!

  """
  Settlement destination:
  Could be null when originalDestination is onChain/LN
  and the payeee does not have a WalletName
  """
  recipientWalletName: WalletName
}

type OnChainTransaction implements Transaction {
  id: ID!
  direction: TxDirection!
  amount: TxAmount!
  settlementAmount: SatAmount!
  memo: Memo
  status: TxStatus!
  createdAt: Date!

  address: OnChainAddress!
}

type LnTransaction implements Transaction {
  id: ID!
  direction: TxDirection!
  amount: TxAmount!
  settlementAmount: SatAmount!
  memo: Memo
  status: TxStatus!
  createdAt: Date!

  paymentHash: LnInvoincePaymentHash! # V: 256 bits (64 chars)
  "Which node the payment was made to"
  # receivingNode: LnNode!
}

# type ExchangeTransaction implements Transaction {
#   rate: ...
#   fee: ...
# }

# ?: Account? Multiple wallets
interface Wallet {
  id: ID!
  storageCurrency: Currency
  balance: SignedAmount! # Can be negative for dealers
  transactions: [Transaction!]! # Connection
}

type BTCWallet implements Wallet {
  id: ID!
  balance: SignedAmount!
  transactions: [Transaction!]! # Connection
}

type FiatWallet implements Wallet {
  id: ID!
  currency: Currency!
  balance: SignedAmount!
  transactions: [Transaction!]! # Connection
}

type MapInfo {
  title: String!
  coordinates: Coordinates!
}

type Coordinates {
  longitude: Float!
  latitude: Float!
}

type MapMarker {
  id: ID!
  username: Username
  mapInfo: MapInfo!
}

enum ExpectedConfirmationTime {
  NEXT_BLOCK
  NEXT_HOUR
  NEXT_DAY
  NEXT_WEEK
}

type OnChainTxFee {
  amount: SatAmount!
  expectedConfirmationTime: ExpectedConfirmationTime!
}

type GaloyGlobalSettings {
  instanceBaseCurrency: Currency
  depositFeePercentage: Float # Static
}

#########################
### Root Query
#########################
type Query {
  galoyGlobalSettings: GaloyGlobalSettings
  btcUsdPriceListForGraph(range: PriceGraphRange!): [BtcUsdPrice!]
  quizQuestions: [QuizQuestion!]
  merchantMapMarkers: [MapMarker!] # TODO: Map focus Connection | X merchants here
  mobileVersions: MobileVersions
  walletNameAvailable(walletName: WalletName!): Boolean # TODO: security concerns / rate-limit
  onChainTxFee(distination: OnChainAddress!, amount: SatAmount!): [OnChainTxFee!] # Dynamic

  # settings... # FuturePlanning
}

#########################
### Input and Payload types for mutations
#########################

enum PaymentErrorCode {
  ACCOUNT_LOCKED
  LIMIT_EXCEEDED
  INSUFFICENT_BALANCE
  INVOICE_PAID
  NO_LIQUIDITY # LN
  NO_ROUTE # LN
}

enum InputErrorCode {
  INVALID_INPUT
  VALUE_TOO_SHORT
  VALUE_TOO_LONG
  VALUE_NOT_ALLOWED
}

interface Error {
  message: String!
}

type InputError implements Error {
  message: String!
  code: InputErrorCode!
  field: [String!]
}

type PaymentError implements Error {
  message: String!
  code: PaymentErrorCode!
}

enum TxStatus {
  PENDING
  SUCCESS
  FAILURE
}

input PhoneInput {
  phone: Phone!
}

input LoginInput {
  phone: Phone!
  code: OneTimeAuthCode!
}

input LanguageUpdateInput {
  language: Language!
}

input ContactUpdateInput {
  username: Username!
  name: Name!
}

input DeviceNotificationTokenInput {
  deviceToken: String!
}

input OnChainPaymentInput {
  address: OnChainAddress!
  amount: SatAmount!
  memo: Memo
}

input OnChainPaymentAllInput {
  address: OnChainAddress!
  memo: Memo
}

input LnInvoicePaymentInput {
  invoice: LnInvoice!
  memo: Memo
}

input LnNoAmountInvoiceFeeProbeInput {
  invoice: LnNoAmountInvoice!
  amount: SatAmuont!
}

input QuizQuestionUpdateCompletedInput {
  ids: [ID!]!
}

input LnInvoiceReceiveStatusInput {
  paymentHash: LnInvoicePaymentHash!
  paymentSecret: LnInvoicePaymentSecret!
}

input LnNoAmountInvoiceCreateInput {
  memo: Memo
}

input LnInvoiceCreateInput {
  amount: SatAmount!
  memo: Memo
}

input LnNoAmountInvoiceCreateForUserInput {
  recipientID: Username!
  memo: Memo
}

input LnInvoiceCreateForUserInput {
  recipientID: Username!
  amount: SatAmount!
  memo: Memo
}

input LnNoAmountInvoicePaymentInput {
  invoice: LnNoAmountInvoice!
  amount: SatAmount!
  memo: Memo
}

input LnInvoiceFeeProbeInput {
  invoice: LnInvoice!
}

input UserPaymentInput {
  recipientID: Username!
  amount: SatAmount!
  memo: Memo
}

type LnInvoicePayload {
  errors: [Error!]!
  lnInvoice: LnInvoice
}

type LnNoAmountInvoicePayload {
  errors: [Error!]!
  lnInvoice: LnNoAmountInvoice
}

type OnChainAddressPayload {
  errors: [Error!]!
  onChainAddress: OnChainAddress
}

type PaymentStatusPayload {
  errors: [Error!]!
  status: TxStatus
}

type SatAmountPayload {
  errors: [Error!]!
  amount: SatAmount
}

type AuthTokenPayload {
  errors: [Error!]!
  authToken: AuthToken
}

type AuthTokenPayload {
  errors: [Error!]!
  quizQuestions: [UserQuizQuestion!]
}

type SuccessPayload {
  errors: [Error!]!
  success: Boolean
}

type LnInvoiceReceivePayload {
  errors: [Error!]!
  status: InvoiceReceiveStatus!
}

#########################
### Root Mutation
#########################
type Mutation {
  ## User mutations ##
  userRequestPhoneCode(input: PhoneInput!): SuccessPayload!
  userLogin(input: LoginInput!): AuthTokenPayload!
  userQuizeQuestionsUpdateCompleted(
    input: QuizQuestionUpdateCompletedInput
  ): QuizQuestionsUpdateCompletedPayload!
  userLanguageUpdate(input: LanguageUpdateInput!): UserPayload!
  userContactUpdate(input: ContactUpdateInput!): SuccessPayload!

  ## Device mutations ##
  deviceNotificationTokenCreate(input: DeviceNotificationTokenInput!): SuccessPayload!

  ## onChain mutations ##
  onChainAddressCreate: OnChainAddressPayload! # always a mutation
  onChainAddressCurrent: OnChainAddressPayload! # mutation first time it's issued, then query
  onChainPaymentSend(input: OnChainPaymentInput!): PaymentStatusPayload!
  onChainPaymentSendAll(input: OnChainPaymentAllInput!): PaymentStatusPayload!

  ## lightning mutations ##
  lnNoAmountInvoiceCreate(input: LnNoAmountInvoiceCreateInput!): LnNoAmountInvoicePayload!

  lnInvoiceCreate(input: LnInvoiceCreateInput!): LnInvoicePayload!

  lnNoAmountInvoicePaymentSend(
    input: LnNoAmountInvoicePaymentInput!
  ): PaymentStatusPayload! # FINAL (mobile)

  lnInvoicePaymentSend(input: LnInvoicePaymentInput!): PaymentStatusPayload!

  lnNoAmountInvoiceFeeProbe(intput: LnNoAmountInvoiceFeeProbeInput!): SatAmountPayload!

  lnInvoiceFeeProbe(intput: LnInvoiceFeeProbeInput!): SatAmountPayload!
  # lnPushPaymentFeeProbe(intput: LnPushPaymentFeeProbeInput!): SatAmountPayload! # FuturePlanning

  ## mutations that do not require auth ##
  ## Receive payment from anonymous source ##
  lnNoAmountInvoiceCreateForUser(
    input: LnNoAmountInvoiceCreateForUserInput!
  ): LnNoAmountInvoicePayload! # FINAL (lnpage)
  # No use case yet
  lnInvoiceCreateForUser(input: LnInvoiceCreateForUserInput): LnInvoicePayload!

  ## Ledger entry (not part of LN) ##
  intraLedgerPaymentSend(input: UserPaymentInput!): PaymentStatusPayload! # FINAL (mobile)

  # businessAccountCreate(input: BusinessAccountCreateInput!): BusinessAccountPayload!
  # businessAccountAddWallet(input: BusinessAccountAddWalletInput!): WalletPayload!
  # businessAccountDisableWallet
  # businessAccountAddUser()
  # businessAccountRemoveUser()
  # permissions: viewBalance, viewAllTransactions, viewRecentTransactions, refund?, receive, intraBusinessSend, anySend
  # businessAccountAddPermission()
  # businessAccountRemovePermission()
}

#########################
### Root Subscription
#########################

type Subscription {
  priceCurrent: Price!

  lnInvoiceReceiveStatus(input: LnInvoiceReceiveStatusInput!): LnInvoiceReceivePayload! # FINAL (lnpage)

  # # FuturePlanning
  # newTransactions() {
  #   transactions: [Transactions]!
  # }
}
